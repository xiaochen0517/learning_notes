# 二叉树

## 概述

二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分。

下面是一个简单的二叉树的示例：

![二叉树](photo/104、二叉树.png) 

### 二叉查找树

二叉查找树是在二叉树的基础上，左子节点的值小于当前节点，右子节点的值大于当前节点。基于以上的原则可以构成一个通过判断当前节点值的大小，然后查询对应节点的值从而使查找时间大幅下降的树。

下面是二叉查找树的一个简单示例：

![二叉查找树](photo/105、二叉查找树.png) 



## 平衡二叉树

由于二叉查找树在不断添加比已有节点值大或者小的值时，就会使二叉查找树退化为一个链表。为了避免这种情况发生，于是就出现了二叉查找树，通过在添加和删除时进行左旋或者右旋来保持二叉查找树的平衡。平衡二叉树最重要的特点就是每个节点到其子节点的最大值和最小值不可相差超过 1 。

从 1 开始逐个添加大于 1 的值，最终二叉查找树退化为链表

![二叉查找树退化为链表](photo/106、二叉查找树退化为链表.png) 

接下来分析一下平衡二叉树的判断过程，首先树中添加 1 和 2 两个节点。

![二叉树01](photo/107、二叉树01.png) 

再添加一个节点 3 。

![二叉树02](photo/108、二叉树02.png) 

可以看到上面在添加 3 节点后，根节点 1 的左右节点高度分别是 0 和 2，差值大于 1 所以现在的树需要进行调整。调整的方式就是将当前不平衡的节点向高度小的方向旋转，上面的树需要向左旋转。

下面是左旋转的步骤：

1. 将当前节点的位置由右子节点替代
2. 当前旋转的节点成为右子节点的左子节点
3. 如果有右子节点存在左子节点需要将其左子节点成为旋转节点的右子节点

> 右旋转的步骤与左旋转的步骤相反。

![二叉树左旋01](photo/109、二叉树左旋01.png) 

上面是右侧高度过高的树进行左旋后的结构，如果当前旋转节点 1 右子节点 2 存在左子节点，旋转结构如下图所示：

![二叉树左旋02](photo/120、二叉树左旋02.png) 

下面是左右旋转的代码实现。

```java
/**
 * 左旋转
 * @param n
 *
 *       np                 np
 *       |                  |
 *       n                  nr
 *      / \       ==>      / \
 *    nl   nr             n   rr
 *        / \            / \
 *      rl   rr         nl  rl
 */
private void leftRotate(Node n){
    if (n == null)
        return;
    Node np = n.parent;
    Node nr = n.right;
    if (nr == null)
        return;
    Node rl = nr.left;
    if (np != null)
        if (np.left == n)
            np.left = nr;
        else
            np.right = nr;
    nr.left = n;
    nr.parent = np;
    n.right = rl;
    n.parent = nr;
    if (rl != null)
        rl.parent = n;
}
```

右旋转：

```java
/**
 * 右旋转
 * @param n
 *
 *       np                 np
 *       |                  |
 *       n                  nl
 *      / \       ==>      / \
 *    nl   nr            ll   n
 *   / \                     / \
 * ll   lr                  lr  nr
 */
private void rightRotate(Node n){
    if (n == null)
        return;
    Node np = n.parent;
    Node nl = n.left;
    if (nl == null)
        return;
    Node lr = nl.right;
    if (np != null)
        if (np.left == n)
            np.left = nl;
        else
            np.right = nl;
    nl.right = n;
    nl.parent = np;
    n.left = lr;
    n.parent = nl;
    if (lr != null)
        lr.parent = n;
}
```

> 由于平衡二叉树在添加节点和删除节点时都需要对当前的所有节点的左右子树进行高度判断，所以完全平衡二叉树的插入和删除的效率是十分低下的，所以就出现了 2-3-4树。

# 2-3-4树

2-3-4树有着和二叉树很多不同的特点，其操作也会相对复杂。首先我们可以发现上面的二叉树都是在外部节点，也就是树最下方去新增节点，也就是说二叉树是向下生长的。如果在向下生长的过程中会发生左右子节点高度不同的情况，如果将树设计成向上生长不就会自动实现平衡功能，当子节点添加之后不断向父节点推送子节点从而实现树的平衡。

2-3-4树的最大的特点之一就是其是向上生长的，其可以在生长的过程中自然而然的实现子树的高度平衡。又因为其的节点最多可以储存 3 个值且可以有 4 个子节点，从而使得其逻辑较为复杂。

2-3-4树中有三种状态的节点，下面是示例图：

![2-3-4树节点类型](photo/121、2-3-4树节点类型.png) 

其中的 2-3-4 即为节点可以存在几个子节点，当节点中只有一个值时只存在左右子节点，规则与二叉树的相同左侧小值右侧大值。当节点中存在两个值时，还可以有中间子节点，其值就是节点中两个值之间的值。4 节点也是同理，下面是节点及其子节点的示例：

![2-3-4树子节点](photo/122、2-3-4树子节点.png) 

那么 2-3-4 树是如何实现向上生长的，又是如何自动实现平衡的。

依旧是从 1 开始逐个新增元素，首先是前三个步骤。

![2-3-4树新增01](photo/123、2-3-4树新增01.png) 

可以看到，其由 2 节点新增之后会变成 3 和 4 节点，接着再新增一个节点，步骤如下：

1. 将已有的4节点拆分为 3 个独立的 2 节点，中间值上移一层成为上级节点。
2. 将新增的新值添加到拆分开的对应的子节点中

![2-3-4树新增02](photo/124、2-3-4树新增02.png) 

如果新增的值是 2.5 只需要将其与 3 结合，2.5 在 3 的左侧即可，如果再次新增只需将新增的值添加到对应的节点中，构成一个新的 4 节点即可。

![2-3-4树新增03](photo/125、2-3-4树新增03.png) 

当再次新增 6 时，与上面 4 节点拆分相同，需要将 4 上移与 2 进行合并构成一个 3 节点，然后将 6 与 5 进行合并构成一个 3 节点即可，效果如下图所示。

![2-3-4树新增04](photo/126、2-3-4树新增04.png) 

借下来的流程就和上面介绍的相同，新的值会不断的把已有的值向上顶，从而不断增加树的高度，但是子节点的高度永远是平衡的。

![2-3-4树新增05](photo/127、2-3-4树新增05.png) 

 





# 红黑树

红黑树合并了平衡二叉树和 2-3-4树的部分特点，通过红色和黑色来表示 2-3-4树中的不同节点，从而实现向上生长并实现子树平衡。

## 等价关系

下面是 2-3-4树与红黑树的等价关系。

![红黑树等价关系](photo/128、红黑树等价关系.png) 

可以看到红黑树其实是一个二叉树并通过颜色的方式来分别表示 2-3-4树中的三种状态的节点，红黑树只使用了 2-3-4树储存数据的概念，而真正实现平衡的方式还是通过节点的旋转来实现。通过节点颜色的转换以及旋转，使得红黑树使用 2-3-4 树的数据储存逻辑，同时实现比平衡二叉树更高的性能以及比 2-3-4 树更加简单的实现。

## 红黑树特点

下面是一些红黑树的特点。

1. 根节点一定是黑色
2. 不可以有两个连续的红色节点
3. 根节点到任何叶子节点的黑色节点数量相同
4. 新添加的节点永远是红色

通过上面的等价关系可以得出，黑色的父节点和红色的子节点构成的部分在 2-3-4树中就是一个节点，通过 2-3-4 树添加节点的方式，我们可以推导出红黑树添加节点的方式。

## 添加节点

### 首个节点

首先是添加单个节点，红色节点添加进树之后由于其是根节点，所以就会变为黑色。

![红黑树添加01](photo/129、红黑树添加01.png) 

### 第二节点

添加第二个节点时发现父节点的颜色是黑色直接添加即可，此处的逻辑相当于 2-3-4 树添加第二个节点，将 2 节点变为 3 节点的过程。

![红黑树添加02](photo/130、红黑树添加02.png) 

### 第三节点

此时节点就组成了相当于 2-3-4 树中的 3 节点，此时再添加一个节点就组成了 4 节点，现在添加节点时会出现两种情况，一种是新的节点是当前红色节点的子节点，另一种情况是新的节点是当前黑色节点的另一个子节点。由于 4 节点使用红黑树来表示就是一个黑色根节点和两个红色的子节点，所以第二种情况并不需要调整红黑树的结构。

下面是不需要调整和变色的树的结构。

![红黑树添加03](photo/131、红黑树添加03.png) 

但是如果新添加的节点在上方的红色节点下，就需要将其改变为 4 节点的对应状态，此时就需要对节点进行变色和旋转。

第一种情况是第二个红色节点在根节点的右侧，新添加的节点也在第二个红色节点的右侧，如下图左侧的结构所示。根据 2-3-4 树的等价原理，黑色的根节点应该是左右两个红色节点之间的值，而当前状态下中间值是黑色节点下的第一个红色节点。此时就需要将黑色根节点变为红色，中间的红色节点变为黑色，再依据根节点对树进行左旋，最后得到对应 4 节点的树结构。

![红黑树添加04](photo/132、红黑树添加04.png) 

还有一种情况是新增的节点处于根节点右侧红色节点的左子节点，状态如下图所示。此时中间值就变成了底部的红色叶子节点，此时只需要将树依据根节点的右子节点进行右旋，最后就可以得到和上方状态相同的树结构，再依次进行上方的操作即可将树变为 4 节点的对应结构。

![红黑树添加05](photo/133、红黑树添加05.png) 

剩下的两种情况就是添加的节点在都在根节点的右侧，旋转的方式正好与上面的相反。

![红黑树添加06](photo/134、红黑树添加06.png) 

![红黑树添加07](photo/135、红黑树添加07.png) 

### 第四节点

接下来添加第四个元素，根据上方 2-3-4 树的添加逻辑可知，在添加第四个节点时需要将已有的 4 节点进行拆分，最后新添加的节点在合适的位置与指定的节点合并为一个 3 节点。在红黑树中进行此操作较为简单，只需要将节点变色即可，将已有的 4 节点结构的颜色进行反色，最后就相当于将 4 节点进行了拆分操作，而新添加的红色节点就正好与其父节点构成了一个 3 节点结构。

在红黑树中对应的 2 节点状态应该是一个黑色节点，为什么在拆分时把根节点变为了红色，原因是如果当前顶部节点上面还有节点，那么这个**顶部节点就要和上层的节点进行合并操作**，此时将其变为红色是为了将其当做一个新加入的节点需要对树进行递归判断，直至根节点为止，具体的操作步骤将会在下面的拆分4节点进行详解。

![红黑树添加08](photo/136、红黑树添加08.png) 

在进行完成上一步的操作之后，我们需要去判断顶部的红色节点是否是根节点，如果是根节点说明操作已经完成了，最后将根节点变为红色即可。

### 拆分4节点递归操作

当新增节点的祖父节点（上方的顶部节点）不是根节点时，当前的树就会有两种情况。

- 祖父节点的父节点为黑色

![拆分4节点递归01](photo/141、拆分4节点递归01.png) 

- 祖父节点的父节点为红色

![拆分4节点递归02](photo/142、拆分4节点递归02.png) 

如果当前是第一种情况，那么当前树也会有两种状态。

- 祖父节点的兄弟节点为红色，意思也就是当前祖父节点的父节点与祖父节点的兄弟节点构成了一个 3 节点，此时祖父节点变为红色正好与这两个节点构成了一个 4 节点，说明树此时不需要调整。

![拆分4节点递归03](photo/143、拆分4节点递归03.png) 

- 祖父节点的兄弟节点为黑色或者为空（为空的节点默认为黑色），此时祖父节点的父节点和祖父节点的兄弟节点都是两个独立的 2 节点，此时祖父节点变为红色正好与祖父节点的父节点构成了一个 3 节点，此时的树也不需要调整。

![拆分4节点递归04](photo/144、拆分4节点递归04.png) 

依据上方的分析可以得出需要进行调整的状态是，祖父节点的父节点也是一个红色，此时就需要对树进行调整。

而当前构成双红的树也存在两种状态。

- 祖父节点的叔叔节点为黑色

下面是新增 11 时 6 和 9 需要变为黑色，而 7 需要变为红色，但是 7 变为红色之后与 5 就变成了双红，而 7 的兄弟节点为黑色，此时还需要对节点进行调整。

![红黑树新增双红01](photo/138、红黑树新增双红01.png) 

下图是调整完 6 7 9 之后出现双红冲突时的状态。

![红黑树新增双红02](photo/139、红黑树新增双红02.png) 

此时就需要再次将 7 认为一个新加入的节点进行一次调整。此时 7 的叔叔节点 1 是黑色，此时的状态就等同于上方添加第三个节点时的状态，需要依据 3 进行左旋。所以在拆分 4 节点时需要对祖父节点进行递归调整，直至调整到根节点为止。

旋转节点

![红黑树新增双红03](photo/140、红黑树新增双红03.png) 

如果当前叔叔节点是黑色或者为空而当前的父节点为红色时，则表示当前祖父节点与父节点组成了一个 3 节点，此时的情况就相当于上方添加第三个节点时的情况，只需要对当前的祖父节点进行旋转。

至此就将 2-3-4 树的添加规则完美转换成了红黑树的添加规则，通过这种方式就利用二叉树加红黑节点的方式实现了红黑树的数据结构。

下面是新添加的节点的父节点的叔叔节点为空或者是黑色时都使用旋转加变色即可使红黑树合法

![红黑树添加09](photo/137、红黑树添加09.png) 

